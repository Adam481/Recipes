################################################################################
###																			 ###
####							Interfaces									 ###
###																			 ###
################################################################################



################################################################################
#
#		Nongeneric Interfaces (System.Collections) - obsolate
#
################################################################################


Thouse interfaces still exist because of backwards compatibilty. When generic
interfaces was created lots of software was dependend on nogeneric version.
So all generic interfaces implement nongeneric version therefore if you want
to implement your own collection you muast implement nongeneric interaces as 
well. 

- IEnumerable - Returns an object implementing the IEnumerator interface
- IEnumerator - Enables foreach style iteration of collection items.
- ICollection - general characteristics (e.g., size, enumeration, and 
				thread safety) for all nongeneric collection types.
- IList 	  - Provides behavior to add, remove, and index items in a 
				sequential list of objects.
- ICloneable  - Allows the implementing object to return a copy of itself to
				the caller.
- IDictionary - Allows a nongeneric collection object to represent its contents 
				using key/value pairs.


################################################################################


### IEnumerator  (System.Collections)


	Detaild description in IEnumerator<T> seciton.

public interface IEnumerator
{
	object Current { get; }		// Gets the current element in the collection
	
	bool MoveNext();		    // Advances the enumerator to the next element.
	void Reset()			    // Sets the enumerator to its initial position, 
								// which is before the first el. in the collection.
}				


				

################################################################################
#
#		     Generic Interfaces (System.Collections.Generic)
#
################################################################################



################################################################################


### IEnumerable<T>


It declare object that can be enumerated (iterated). 
LINQ hooks in here (Extension methods).
You don't neccessarly have to know how enumeration process looks in details 
foreach - doas all work for you.

public interface IEnumerable<T> : IEnumerable
{
	IEnumerator<T> GetEnumerator();			// thing that does the enumerating
}


Implementation:

	1. You need class that implements IEnumerator<T> methods. 
	2. You need implement IEnumerable<T> on youc collection and implement
	   method that return IEnumerator<T>.

	AllDaysOfWeek allDays = new AllDaysOfWeek();
	   
	public class AllDaysOfWeek : IEnumerable<string>
	{
		public IEnumerator<string> GetEnumerator()
		{
			yield return "Mondey";						// the simplest way to implement correct GetEnumerator()
			yield return "Tuesday";						// when C# compiler encounters this yield return statement
			yield return "Wednesday";					// isinde method that return IEnumerator interface 
		}												// it will write the enumerator for you. 
		
		IEnumerator IEnumerable.GetEnumerator()			// methods comes from non generic IEnumerable
		{
			return GetEnumerator();						// visable only when we convert it to non generic
		}												// IEnumerable  - problably it will never happen.
	}
	   
	   

################################################################################


### ICollection<T>


It declares sth what we think of as a collection. (In memory data structure
that contains one or more elements). So its a collection but it not define any
information about the characteristics of the collection. (nothing byond that).
It provides method that allows you modify the content of a collection.

public interface ICollection<T> : IEnumerable<T>, IEnumerable
{
	int Count {get; }		 		// Coll.. must know how many items they contains
	bool IsReadOnly {get; }         // true - read-only; otherwise - false.
	
	void Add(T item);
	void Clear();
	void CopyTo(T[] array, int arrayIndex);	 // Copies the el. to an Array, starting at a particular index.
	bool Contains(T item);
	bool Remove(T item);		    // Removes the first occurrence of a specific object
}

Notes:
	- We have LINQ count() extension method. It's much quicker to retrieve
	  number of elements using count properties. LINQ methods have to iterate
	  over all element to count them. Properties just know this.
	- IsReadOnly - if it is true operation like: Add, Remove, Clear are not
	  allowed. the IsReadOnly property of an array that is cast or converted 
	  to an ICollection<T> object returns true. If you try add sth to the 
	  collection - NotSupportedException will be returned during compilation
	- Even if above are true - we can modify element using index notation

	  
	  
################################################################################


### IList<T>


Collections give us ability to look up its elements with an index. To achive 
this, interface uses the generic indexer as you see below.

public interface IList<T> : ICollection<T>, IEnumerable<T>, IEnumerable
{
	T this[int index] { get; set; }  // Gets or sets the element at the specified index.

	int IndexOf(T item);	         // Find the index of a specific item in the IList<T>.
	void Insert(int index, T item);  // Inserts an item to the IList<T> at the specified index
	void RemoveAt(int index);		 // Removes the IList<T> item at the specified index.
}



################################################################################
  
  
### IDictionary<TKey, TValue>


It is ablo to look up elements with keys. There is a clas in .NET that is 
responsible for storing key value pairs. Dictionary is acctualy a collection
of object that are created base on this class. We can see that when we look 
at base interfaces.

class KeyValuePair<TKey, TValue>   (elements:  new KeyValuePair("a", 12))


public interface IDictionary<TKey, TValue> : ICollection<KeyValuePair<TKey,TValue>>, 
											 IEnumerable<KeyValuePair<TKey,TValue>>, 
											 IEnumerable
{
	TValue this[TKey key] { get; set; }  // Gets or sets the element with the specified key.
	ICollection<TKey> Keys { get; }      // Gets an ICollection<T> containing the keys
	ICollection<TValue> Values { get; }  // Gets an ICollection<T> containing the values
	
	void Add(TKey key, TValue value);    // Adds an element with the provided key and value
	bool ContainsKey(TKey key);			 // Check if dictionary contains an element with the specified key.
	bool Remove(TKey key);						   // Removes the element with the specified key 
	bool TryGetValue(TKey key, out TValue value);  // Gets the value associated with the specified key.
}



################################################################################


### ISet<T>


Allow us to do set operations with other collections.

public interface ISet<T> : ICollection<T>, IEnumerable<T>, IEnumerable
{
	bool Add(T item);								 // Adds an el. to the current set and returns a value to indicate if the element was successfully added.
	void ExceptWith(IEnumerable<T> other);			 // Removes all elements in the specified collection from the current set.
	void IntersectWith(IEnumerable<T> other);		 // Modifies the current set so that it contains only elements that are also in a specified collection.
	void SymmetricExceptWith(IEnumerable<T> other);  // Modifies the current set so that it contains only elements that are present either in the current set or in the specified collection, but not both.
	void UnionWith(IEnumerable<T> other);			 // Modifies the current set so that it contains all elements that are present in the current set, in the specified collection, or in both.
	bool IsProperSubsetOf(IEnumerable<T> other);     // Determines whether the current set is a proper (strict) superset of a specified collection.
	bool IsSubsetOf(IEnumerable<T> other);			 // Determines whether a set is a subset of a specified collection.
	bool IsProperSupersetOf(IEnumerable<T> other);   // Determines whether the current set is a proper (strict) superset of a specified collection.
	bool IsSupersetOf(IEnumerable<T> other);		 // Determines whether the current set is a superset of a specified collection.
	bool Overlaps(IEnumerable<T> other);			 // Determines whether the current set overlaps with the specified collection.
	bool SetEquals(IEnumerable<T> other);			 // Determines whether the current set and the specified collection contain the same elements.
}



################################################################################


### IReadOnlyCollection<T> 


This collection only have one properties. So all standard acction are not 
available. That is why the collection is readonly.

public interface IReadOnlyCollection<T> : IEnumerable<T>, IEnumerable
{
	int Count { get; }			
}



################################################################################


### IReadOnlyList<T>


The collection know how many item it has and is able to look up element by 
index.

public interface IReadOnlyList<out T> : IReadOnlyCollection<T>, 
										IEnumerable<T>, IEnumerable
{
	T this[int index] { get; }		// Gets the el. at the specified index 
}									   in the read-only list.



################################################################################


### IReadOnlyDictionary<TKey, TValue>


Non of the collection methods allow to modify values. 

public interface IReadOnlyDictionary<TKey, TValue> : IReadOnlyCollection<KeyValuePair<TKey,TValue>>, 
													 IEnumerable<KeyValuePair<TKey,TValue>>, 
													 IEnumerabl
{
	TValue this[TKey key] { get; set; }  // Gets or sets the element with the specified key.
	IEnumerable<TKey> Keys { get; }      // standard IDictionary return ICollection
	IEnumerable<TValue> Values { get; }  // standard IDictionary return ICollection
	
	bool ContainsKey(TKey key);
	bool TryGetValue(TKey key, out TValue value);
}



################################################################################
	

### IComparer<T>


Implement this method to provide a customized sort order comparison for type T.

public interface IComparer<in T>
{
	int Compare(T x,T y);  	// return number: less than 0 if x<y, 
}										   greater than 0 if x>y,
													    0 when x=y

Implementation:

	class IntComparer : IComparer<int>
	{
		public int Compare(int x, int y)
		{
			return x - y;			// easiest implementation
		}
	}
														
	or 

    class UncasedStringComparer : IComparer<int>
	{
		public string Compare(string x, string y)
		{
			return string.Compare(x,y, StringComparison.InvariantCultureIgnoreCase);
		}
	}



################################################################################


### IEqualityComparer<T>


This interface allows the implementation of customized equality comparison 
for collections. It determinate only if elements are queues or not. A default 
implementation is provided by the Default property of the EqualityComparer<T>
class. This interface supports only equality comparisons. Customization of 
comparisons for sorting and ordering is provided by the IComparer<T> generic 
interface. We recommend that you derive from the EqualityComparer<T> class 
instead of implementing the IEqualityComparer<T> interface, because the 
EqualityComparer<T> class tests for equality using the IEquatable<T>.Equals 
method instead of the Object.Equals method.

public interface IEqualityComparer<in T>
{
	bool Equals(T x,T y);			// Determines whether the specified objects are equal.
	int GetHashCode(T obj);			// Returns a hash code for the specified object.
}

Implementation:

	class UncasedStringEqualityComparer : IEqualityComparer<string>
	{
		public bool Equals(string x, string y)
		{
			return x.ToUpper() == y.ToUpper();
		}
		
		public int GetHashCode(string obj)
		{
			obj.ToUpper().GetHashCode();
		}
	}
	
	x.GetHashCode != y.GetHashCode  - hash code are not equal. 
	obj.ToUpper().GetHashCode();	- every string returns a HasCodeValue
									  the same as UpperCase string.
									  (thanks to that values will be equal)
	
	Two object that schould be equal must return the same hash code.

	.. describe StringComparer



################################################################################


### IEnumerator<T>


	Allow object to be enumareted. Define the way object is enumareted.

public interface IEnumerator<out T> : IDisposable, IEnumerator
{
	T Current { get; }

	void Dispose()				// Inherited from IDisposable.
	void Reset()				// Inherited from IEnumerator.	// Sets the enumerator to its initial position, 
	bool MoveNext()				// Inherited from IEnumerator.  
}								   true  - move to the next item successfully
								   false - no more item in the collection (can not move futher).

How it works:
		
	You can think about the enumerator as lika a cursor. 
	
			       <- initial step not point at eny item in the collection (before first item)
	||| 1st |||		- you can move to 1st item using MoveNext and call property Current to get that item. 
	||| 2st |||		- call MoveNext to move pointer to the 2st item.  etc..
	||| 3st |||
	||| 4st |||		- when we call MoveNext - return value = false (there is no way to move futher)

	Enumerating process does not need to know how many item is in the collection.
	There is no need to look ahead. So item that is enumerated can come from
	some outside source and can be load when is required. It is crutial part of
	LINQ's abilltiy to do Lazy-Evaluation. (retrieving item from the collection 
	only when it is required).
	
Iteration:

	public static void DisplayItem<T>(IEnumerable<T> collection)
	{
		using(IEnumerable<T> enumerator = collection.GetEnumerator())  // extract enumerator
		{
			bool isNexItemInCollection = enumerator.MoveNext();		   // set enumerator to first item
			
			while(isNexItemInCollection)							   // work - if more item exist
			{
				T item = enumaretor.Currentl						   // extract current item
				Console.WriteLine(item);
				isNexItemInCollection.MoveNext();					   // try move "pointer" and check if ok
			}
		}
	}

	
Foreach:

	When compiler see foreach loop it replaces it with something similar to
	our DisplayItem method. Bu there is one significant exception.
	
	WHen compiler notice that the type in foreach is a array it will convert 
	foreach loop into a for loop to index over elements (it is much more efficient
	way to achive the same result). Of course array type has to be explicity
	declare, otherwise will be treated like rest of the types.
	
	Foreach must work independently. (modification in one iteration can couse
	problem with other iterations) That is way each enumartion must have its own
	independent enumerator. GetEnumerator has to return new freash instance every
	time is called ( no caching allowed).
	
	Enumerator does not implement any methods that allow you modify object
	in the collection. (read-only). But every code that have direct reference
	to item in the collection can modify this item. MoveNext method in many
	implementation check if the collection changed and throw an extension if
	change will be detected. Most collection internally stores version number.
	If a collection is changed - this number is incremented. The checking process
	base on this number. The extension is when we use an array and index inside
	in foreach. (because under the hood for array type foreach loop is converted
	to for loop).

Interesting fact: 
	
	This method works also with strings. String implements IEnumerable<char> 
	so we can treat it as char collection.
	
	DisplayItem("Hello world");

Implementation:

	public class BoxEnumerator : IEnumerator<Box>
	{
		private BoxCollection _collection;
		private int curIndex;
		private Box curBox;

		public BoxEnumerator(BoxCollection collection)
		{
			_collection = collection;
			curIndex = -1;
			curBox = default(Box);
		}

		public bool MoveNext()
		{
			//Avoids going beyond the end of the collection.
			if (++curIndex >= _collection.Count)
			{
				return false;
			}
			else
			{
				// Set current box to next item in collection.
				curBox = _collection[curIndex];
			}
			return true;
		}

		public void Reset() { curIndex = -1; }

		void IDisposable.Dispose() { }

		public Box Current
		{
			get { return curBox; }
		}

		object IEnumerator.Current
		{
			get { return Current; }
		}
	}

	
	
	
################################################################################
#
#		    		 System Interfaces (System)
#
################################################################################


		
################################################################################	

	
### ICustomFormatter

	
################################################################################


### IEquatable<T>			

	
	
################################################################################

###	IComparable<T>


	
################################################################################


### IDisposable


public interface IDisposable
{
	void Dispose();
}










/ --- poprawiæ poni¿sze - przepisac do powy¿szych 











