using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Recipes.Common.DotNetFramework
{

    public static class LinqToObject
    {
        // OfThings, Where
        public static void Filtering()
        {
            object[] things = { "Glasses", 2, "Books" };

            ArrayList listOfThings = new ArrayList(things);

            var query1 = listOfThings.OfType<int>();

            var query2 = listOfThings.OfType<string>()
                                     .Where(s => s.Length < 6);

            ShowAll<int>(query1, "\nWynik query 1");
            ShowAll<string>(query2, "\nWynik query 2");
        }

        // OrderBy, OrderByDescending
        // ThenBy, ThenByDescending     (secondary sort)
        // Reverse
        public static void Sorting()
        {
            string[] names = { "Bob", "Alice", "Alex", "Carol" };

            var query1a = names.OrderBy(s => s)
                             .ThenBy(s => s.Length);

            var query1b = from name in names
                          orderby name, name.Length
                          select name;

            // OrderBy return interface: IOrderedEnumerable<T>
            // ThenBy is an extension method for IOrderedEnumerable<T>
            var query = Process.GetProcesses()
                               .OrderBy(p => p.WorkingSet64)
                               .ThenBy(p => p.Threads.Count);
            // .Where(p => p.ProcessName.Length < 10) - to return IEnumerable<T>
            // Be carefull: query is now IOrderedEnumerable<T>
            // query.Where(...) - will not going to be working

            ShowAll<string>(query1a, "\nQuery 1a: standard ordering");
            ShowAll<string>(query1b, "\nQuery 1b: standard ordering");
            ShowAll<string>(query1a.Reverse(), "\nQuery 1a: revers ordering");
            Console.WriteLine("\nTest process query");
            foreach (var item in query)
            {
                Console.WriteLine(item.Id);
            }

        }

        // Distinct, Except, Intersect, Union
        public static void SetOperations()
        {
            int[] twos = { 2, 4, 6, 8, 10 };
            int[] threes = { 3, 6, 9, 12, 15 };

            // 6                             - czesc wspolna
            var intersection = twos.Intersect(threes);
            // 2, 4, 8, 10                   - co ma lewa czego nie ma prawa
            var except = twos.Except(threes);
            // 2, 4, 6, 8, 10, 3, 9, 12, 15  - wszystko bez duplikacji 
            var union = twos.Union(threes);

            var books = new List<Book>
            {
                new Book { Author = "Scott", Name = "Programming WF" },
                new Book { Author = "Fritz", Name = "Essentail ASP.NET" },
                new Book { Author = "Scott", Name = "Programming WF" }
            };

            var query = books.Distinct();       // we will get Scott twice because
            ShowAll(query.Select(n => n.Name)); // becuase two reference refer to different object
            // We have tree solution:
            // 1. overriding Equles method and hash code (very complicated way)
            // 2. override Distinct (it is also to big deal)
            // 3. Project a book in a new anonymous type;
            var query2 = books.Select(b => new { b.Name, b.Author })
                              .Distinct();
            ShowAll(query2.Select(n => n.Name), "\nCorrect distinct result:");

            // Operators that test quality use default IEqualityComparer
            // Anonymous types generated by C# compiler are special
            // Override Equals and GetHashCode
            // Uses all public properties on type to test for quality

        }

        // All, Any, Contains
        public static void Quantifiers()
        {
            int[] twos = { 2, 4, 6, 8, 10 };

            // true     - all match criteria
            bool areAllEvenNumbers = twos.All(i => i % 2 == 0);
            // true     - any match criteria
            bool containMultipleOfThree = twos.Any(i => i % 3 == 0);
            // false    - element is a part of data set
            bool hasSeven = twos.Contains(7);

            // Evaluate base on several rules
            Book book = new Book { Author = "Herman", Name = "Moby Dick" };

            var bookValidationRules = new List<Func<Book, bool>>()
            {
                b => !String.IsNullOrEmpty(b.Name),
                b => !String.IsNullOrEmpty(b.Author)
            };

            bool isBookValid = bookValidationRules.All(rule => rule(book));

            Console.WriteLine("\nValidation result: {0}", isBookValid);

        }

        // Select, SelectMany
        public static void Projection()
        {
            string[] famousQuotes =
            {
                "Advertising is legalized lying",
                "Advertising is the greatest art form of the twentieth century"
            };

            var query = (from sentence in famousQuotes
                         from word in sentence.Split(' ')
                         select word).Distinct();
            ShowAll(query, "\nAll words:\n");

            // we will get sequence of two string arrays
            var query2 = famousQuotes.Select(s => s.Split(' ')).Distinct();

            // SelectMany means sequence of sequence
            var query3 = famousQuotes.SelectMany(s => s.Split(' ')).Distinct();

            ShowAll(query3, "\nAll words (select many):\n");
        }

        // Skip, SkipWhile   
        // Take, TakeWhile
        public static void Partitioning()
        {
            // Skip elements until a condition or predicate is met
            // Take elements until a condition or predicate is met
            int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

            // 3, 4
            var query = numbers.Skip(2).Take(2);
            ShowAll(query, "\nFrom range 1-9 Skipped 2, Taken 2:\n");

            // 5, 6, 7
            var query2 = numbers.SkipWhile(n => n < 5)
                                .TakeWhile(n => n < 8);
            ShowAll(query2, "\nFrom range 1-9 Skipped while n < 5, Taken while n < 8:\n");

        }

        // Join,
        // GroupJoin
        public static void Joining()
        {
            // Join two sequences on a key and yields a sequence (flat result)
            // Join two sequences on a key and yield groups of sequences (hierarchical result)

            // LINQ Join opertators is an inner Join
            // * Only outputs an element when a match is present
            // * Only allows equijoins
            // GroupJoin can offer outer join capabilities
            // * Can return an outer element with no matching inner elements
            // * Trigger by an into clause in query syntax
            // * Use SelectMany to flatten (additional form clause)



            //    var query = employees.Join(departments,     // inner squence
            //                          e => e.DepartmentID,  // outer key selector
            //                          d => d.ID.            // inner key selector
            //                          (e, d) => new         // result project
            //                          {
            //                              EmployeeName = e.Name,
            //                              DepartmentName = d.Name
            //                          });

            var employees = new List<Employee>
            {
                new Employee { ID=1, Name="Scott", DepartmentID=1 },
                new Employee { ID=2, Name="Poonam", DepartmentID=1 },
                new Employee { ID=3, Name="Andy", DepartmentID=2 }
            };

            var departments = new List<Department>
            {
                new Department { ID=1, Name="Engineering" },
                new Department { ID=2, Name="Sales" },
                new Department { ID=3, Name="Skunkworks" }
            };

            // Inner Join
            var query = from d in departments
                        join e in employees
                            on d.ID equals e.DepartmentID
                        select new
                        {
                            DepartmentName = d.Name,
                            EmployeeName = e.Name
                        };
            ShowAll(query.Select(n => n.EmployeeName + " " + n.DepartmentName), "\nJoin result\n");

            // Inner Join
            var query2 = departments.Join(employees,
                                     d => d.ID,
                                     e => e.DepartmentID,
                                     (d, e) => new
                                     {
                                         DepartmentName = d.Name,
                                         EmployeeName = e.Name
                                     });
            ShowAll(query2.Select(n => n.EmployeeName + " " + n.DepartmentName), "\nJoin 2 result\n");

            // Outer Join like operator
            var query3 = departments.GroupJoin(employees,
                                    d => d.ID,
                                    e => e.DepartmentID,
                                    (d, eg) => new
                                    {
                                        DepartmentName = d.Name,
                                        EmployeeName = eg
                                    });

            var query4 = from d in departments
                         join e in employees
                            on d.ID equals e.ID
                            into eg
                         select new
                         {
                             DepartmentName = d.Name,
                             Employees = eg
                         };

        }

        // GroupBy
        // ToLookup
        public static void Grouping()
        {

        }


        private static void ShowAll<T>(IEnumerable<T> items, string title = "")
        {
            Console.WriteLine(title);
            foreach (var item in items)
            {
                Console.WriteLine(item);
            }
        }


        private static void SplitToEquelGroups()
        {
            var persons = Person.GetPersons();

            persons.ForEach(p => Console.WriteLine($"{p.Id} {p.Name} {p.Surname}"));
            
            int groupCount = 3;
            int groupSize = persons.Count / groupCount;


            Dictionary<int, List<Person>> selected = persons
                .Select((person, index) => new { person, index })
                .GroupBy(o => o.index / groupSize)
                .ToDictionary(o => o.Key, o => o.Select(x => x.person).ToList());
            
            selected.Keys.ToList()
                .ForEach(key => selected[key]
                    .ForEach(v => Console.WriteLine($"{key} {v.Id} {v.Name} {v.Surname}")));

        }
    }


    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int DepartmentID { get; set; }
    }

    public class Department
    {
        public int ID { get; set; }
        public string Name { get; set; }
    }

    public class Book
    {
        public string Author { get; set; }
        public string Name { get; set; }
    }

    class Person
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Surname { get; set; }

        public static List<Person> GetPersons()
        {
            return new List<Person>
            {
                new Person { Id = 1, Name = "Adam", Surname = "Kowalski" },
                new Person { Id = 2, Name = "Paweł", Surname = "Maliszewski" },
                new Person { Id = 3, Name = "Stasiek", Surname = "Nowak" },
                new Person { Id = 4, Name = "Jakub", Surname = "Wisniewski" },
                new Person { Id = 5, Name = "Adam", Surname = "Malinowski" },
                new Person { Id = 6, Name = "Kamil", Surname = "Kraszewski" },
                new Person { Id = 7, Name = "Nikodem", Surname = "Poziomkowski" },
                new Person { Id = 8, Name = "Adrian", Surname = "Stefaniuk" },
                new Person { Id = 9, Name = "Karol", Surname = "Kodorski" }
            };
        }
    }
}
