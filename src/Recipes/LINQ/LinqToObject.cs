using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Recipes.Common.DotNetFramework
{

    public static class LinqToObject
    {
        // OfThings, Where
        public static void Filtering()
        {
            object[] things = { "Glasses", 2, "Books" };

            var listOfThings = new ArrayList(things);

            var query1 = listOfThings
                .OfType<int>();

            var query2 = listOfThings
                .OfType<string>()
                .Where(s => s.Length < 6);

            ShowAll(query1, "\nWynik query 1");
            ShowAll(query2, "\nWynik query 2");
        }


        // OrderBy, OrderByDescending
        // ThenBy, ThenByDescending     (secondary sort)
        // Reverse
        public static void Sorting()
        {
            string[] names = { "Bob", "Alice", "Alex", "Carol" };

            var query1a = names
                .OrderBy(s => s)
                .ThenBy(s => s.Length);

            var query1b = from name in names
                          orderby name, name.Length
                          select name;

            // OrderBy return interface: IOrderedEnumerable<T>
            // ThenBy is an extension method for IOrderedEnumerable<T>
            var query = Process
                .GetProcesses()
                .OrderBy(p => p.WorkingSet64)
                .ThenBy(p => p.Threads.Count);

            // .Where(p => p.ProcessName.Length < 10) - to return IEnumerable<T>
            // Be carefull: query is now IOrderedEnumerable<T>
            // query.Where(...) - will not going to be working

            ShowAll(query1a, "\nQuery 1a: standard ordering");
            ShowAll(query1b, "\nQuery 1b: standard ordering");
            ShowAll(query1a.Reverse(), "\nQuery 1a: revers ordering");
            ShowAll(query, "\nQuery: oreder by - then by");

        }


        // Distinct, Except, Intersect, Union
        public static void SetOperations()
        {
            int[] twos = { 2, 4, 6, 8, 10 };
            int[] threes = { 3, 6, 9, 12, 15 };

            // 6
            var intersection = twos.Intersect(threes);
            // 2, 4, 8, 10
            var except = twos.Except(threes);
            // 2, 4, 6, 8, 10, 3, 9, 12, 15
            var union = twos.Union(threes);

            var books = new List<Book>
            {
                new Book { Author = "Adam", Name = "Programming WF" },
                new Book { Author = "Zenon", Name = "Essentail ASP.NET" },
                new Book { Author = "Adrian", Name = "Programming WF" }
            };

            var query = books.Distinct();       // we will get Scott twice because
            ShowAll(query.Select(n => n.Name)); // two reference point to different object
            // We have tree solution:
            // 1. overriding Equles method and hash code.
            // 2. override Distinct.
            // 3. Project a book in a new anonymous type;

            var query2 = books
                .Select(b => new { b.Name, b.Author })
                .Distinct();

            ShowAll(query2.Select(n => n.Name), "\nCorrect distinct result:");

            // Operators that test quality use default IEqualityComparer
            // Anonymous types generated by C# compiler are special
            // Override Equals and GetHashCode
            // They use all public properties on the type to test for quality
        }


        // All, Any, Contains
        public static void Quantifiers()
        {
            int[] twos = { 2, 4, 6, 8, 10 };

            // true     - all match criteria
            bool areAllEvenNumbers = twos.All(i => i % 2 == 0);
            // true     - any match criteria
            bool containMultipleOfThree = twos.Any(i => i % 3 == 0);
            // false    - element is a part of data set
            bool hasSeven = twos.Contains(7);

            // Evaluate base on several rules
            var book = new Book { Author = "Adam", Name = "Some name" };

            var bookValidationRules = new List<Func<Book, bool>>()
            {
                b => !String.IsNullOrEmpty(b.Name),
                b => !String.IsNullOrEmpty(b.Author)
            };

            bool isBookValid = bookValidationRules.All(rule => rule(book));

            Console.WriteLine("\nValidation result: {0}", isBookValid);
        }


        // Select, SelectMany
        public static void Projection()
        {
            string[] famousQuotes =
            {
                "TEST 1",
                "TEST 2"
            };

            var query = (from sentence in famousQuotes
                         from word in sentence.Split(' ')
                         select word).Distinct();

            ShowAll(query, "\nAll words:\n");

            // we will get sequence of two string arrays
            var query2 = famousQuotes
                .Select(s => s.Split(' '))
                .Distinct();

            // SelectMany means sequence of sequence
            var query3 = famousQuotes
                .SelectMany(s => s.Split(' '))
                .Distinct();

            ShowAll(query3, "\nAll words (select many):\n");
        }


        // Skip, SkipWhile   
        // Take, TakeWhile
        public static void Partitioning()
        {
            // Skip elements until a condition or predicate is met
            // Take elements until a condition or predicate is met
            int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

            // 3, 4
            var query = numbers.Skip(2).Take(2);
            ShowAll(query, "\nFrom range 1-9 Skipped 2, Taken 2:\n");

            // 5, 6, 7
            var query2 = numbers.SkipWhile(n => n < 5)
                                .TakeWhile(n => n < 8);
            ShowAll(query2, "\nFrom range 1-9 Skipped while n < 5, Taken while n < 8:\n");

        }

        // Join,
        // GroupJoin
        public static void Joining()
        {
            // Join two sequences on a key and yields a sequence (flat result)
            // Join two sequences on a key and yield groups of sequences (hierarchical result)

            // LINQ Join opertators is an inner Join
            // * Only outputs an element when a match is present
            // * Only allows equijoins
            // GroupJoin can offer outer join capabilities
            // * Can return an outer element with no matching inner elements
            // * Trigger by an into clause in query syntax
            // * Use SelectMany to flatten (additional form clause)

            //    var query = employees.Join(departments,     // inner squence
            //                          e => e.DepartmentID,  // outer key selector
            //                          d => d.ID.            // inner key selector
            //                          (e, d) => new         // result project
            //                          {
            //                              EmployeeName = e.Name,
            //                              DepartmentName = d.Name
            //                          });

            var employees = new List<Employee>
            {
                new Employee { ID=1, Name="Adam", DepartmentID=1 },
                new Employee { ID=2, Name="Zenon", DepartmentID=1 },
                new Employee { ID=3, Name="Kamil", DepartmentID=2 }
            };

            var departments = new List<Department>
            {
                new Department { ID=1, Name="Engineering" },
                new Department { ID=2, Name="Sales" },
                new Department { ID=3, Name="Skunkworks" }
            };

            // Inner Join
            var query = from d in departments
                        join e in employees
                            on d.ID equals e.DepartmentID
                        select new
                        {
                            DepartmentName = d.Name,
                            EmployeeName = e.Name
                        };

            ShowAll(query.Select(n => n.EmployeeName + " " + n.DepartmentName), "\nJoin result\n");

            // Inner Join
            var query2 = departments
                .Join(
                    inner: employees,
                    outerKeySelector: d => d.ID,
                    innerKeySelector: e => e.DepartmentID,
                    resultSelector: (d, e) 
                        => new
                        {
                            DepartmentName = d.Name,
                            EmployeeName = e.Name
                        });

            ShowAll(query2.Select(n => n.EmployeeName + " " + n.DepartmentName), "\nJoin 2 result\n");

            // Outer Join like operator
            var query3 = departments
                .GroupJoin(
                    inner: employees,
                    outerKeySelector: d => d.ID, 
                    innerKeySelector: e => e.DepartmentID,
                    resultSelector: (d, eg) 
                        => new
                        {
                            DepartmentName = d.Name,
                            EmployeeName = eg
                        });

            var query4 = from d in departments
                         join e in employees
                            on d.ID equals e.ID
                            into eg
                         select new
                         {
                             DepartmentName = d.Name,
                             Employees = eg
                         };
        }


        // GroupBy
        // ToLookup
        public static void Grouping()
        {

        }


        private static void ShowAll<T>(IEnumerable<T> items, string title = "")
        {
            Console.WriteLine(title);
            foreach (var item in items)
            {
                Console.WriteLine(item);
            }
        }


        private static void SplitToEquelGroups()
        {
            var persons = Person.GetPersons();

            persons.ForEach(p => Console.WriteLine($"{p.Id} {p.Name} {p.Surname}"));
            
            int groupCount = 3;
            int groupSize = persons.Count / groupCount;


            Dictionary<int, List<Person>> selected = persons
                .Select((person, index) => new { person, index })
                .GroupBy(o => o.index / groupSize)
                .ToDictionary(o => o.Key, o => o.Select(x => x.person).ToList());
            
            selected.Keys.ToList()
                .ForEach(key => selected[key]
                    .ForEach(v => Console.WriteLine($"{key} {v.Id} {v.Name} {v.Surname}")));

        }
    }


    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int DepartmentID { get; set; }
    }

    public class Department
    {
        public int ID { get; set; }
        public string Name { get; set; }
    }

    public class Book
    {
        public string Author { get; set; }
        public string Name { get; set; }
    }

    class Person
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Surname { get; set; }

        public static List<Person> GetPersons()
        {
            return new List<Person>
            {
                new Person { Id = 1, Name = "Adam", Surname = "Kowalski" },
                new Person { Id = 2, Name = "Paweł", Surname = "Maliszewski" },
                new Person { Id = 3, Name = "Stasiek", Surname = "Nowak" },
                new Person { Id = 4, Name = "Jakub", Surname = "Wisniewski" },
                new Person { Id = 5, Name = "Adam", Surname = "Malinowski" },
                new Person { Id = 6, Name = "Kamil", Surname = "Kraszewski" },
                new Person { Id = 7, Name = "Nikodem", Surname = "Poziomkowski" },
                new Person { Id = 8, Name = "Adrian", Surname = "Stefaniuk" },
                new Person { Id = 9, Name = "Karol", Surname = "Kodorski" }
            };
        }
    }
}
